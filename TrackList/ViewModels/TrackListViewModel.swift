//
//  TrackListViewModel.swift
//  TrackList
//
//  ViewModel –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç—Ä–µ–∫–ª–∏—Å—Ç–∞–º–∏ –∏ UI-—Å–æ—Å—Ç–æ—è–Ω–∏–µ–º:
//  - –≤—ã–±–æ—Ä –ø–ª–µ–π–ª–∏—Å—Ç–∞
//  - –∏–º–ø–æ—Ä—Ç/—ç–∫—Å–ø–æ—Ä—Ç —Ç—Ä–µ–∫–æ–≤
//  - –æ—á–∏—Å—Ç–∫–∞, —É–¥–∞–ª–µ–Ω–∏–µ, —Å–æ–∑–¥–∞–Ω–∏–µ
//  - –∫–æ–Ω—Ç—Ä–æ–ª—å —Ç–µ–∫—É—â–µ–≥–æ —Å–ø–∏—Å–∫–∞ —Ç—Ä–µ–∫–æ–≤ –∏ –ø–æ—Ä—è–¥–∫–∞
//
//  Created by Pavel Fomin on 28.04.2025.
//

import Foundation
import SwiftUI
import UIKit


@MainActor
final class TrackListViewModel: NSObject, ObservableObject {
    
    
    // MARK: - –°–æ—Å—Ç–æ—è–Ω–∏—è
    
    @Published var tracks: [Track] = []         /// –¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ —Ç—Ä–µ–∫–æ–≤
    @Published var trackLists: [TrackList] = [] /// –í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç—Ä–µ–∫–ª–∏—Å—Ç—ã
    @Published var currentListId: UUID?
    @Published var importMode: ImportMode = .none
    @Published var isShowingSaveSheet = false
    @Published var newTrackListName: String = generateDefaultTrackListName()
    @Published var toastData: ToastData? = nil
    @Published var isEditing: Bool = false
    
    init(trackList: TrackList) {
        self.tracks = trackList.tracks.map { $0.asTrack() }
        self.currentListId = trackList.id
    }
    
    override init() {
        super.init()
        self.tracks = []
    }
    
    // –†–µ–∂–∏–º –∏–º–ø–æ—Ä—Ç–∞ —Ç—Ä–µ–∫–æ–≤
    enum ImportMode {
        case none
        case newList
        case addToCurrent
    }
    
    
    
    // MARK: - –¢—Ä–µ–∫–∏ –∏ —Ç—Ä–µ–∫–ª–∏—Å—Ç—ã
    
    // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ç—Ä–µ–∫–ª–∏—Å—Ç–æ–≤
    func refreshTrackLists() {
        let metas = TrackListManager.shared.loadTrackListMetas()
        trackLists = metas.reversed().map { meta in
            let tracks = TrackListManager.shared.loadTracks(for: meta.id)
            return TrackList(id: meta.id, name: meta.name, createdAt: meta.createdAt, tracks: tracks)
        }
    }
    
    // –í—ã–±–∏—Ä–∞–µ—Ç —Ç—Ä–µ–∫–ª–∏—Å—Ç –∏ –∑–∞–≥—Ä—É–∂–∞–µ—Ç –µ–≥–æ —Ç—Ä–µ–∫–∏
    func selectTrackList(id: UUID) {
        currentListId = id
        loadTracks()
    }
    
    // –ó–∞–≥—Ä—É–∂–∞–µ—Ç —Ç—Ä–µ–∫–∏ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ç—Ä–µ–∫–ª–∏—Å—Ç–∞
    func loadTracks() {
        guard let id = currentListId else {
            print("‚ö†Ô∏è –ü–ª–µ–π–ª–∏—Å—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω")
            return
        }
        let imported = TrackListManager.shared.loadTracks(for: id)
        let metas = TrackListManager.shared.loadTrackListMetas()
        if let meta = metas.first(where: { $0.id == id }) {
            let list = TrackList(id: id, name: meta.name, createdAt: meta.createdAt, tracks: imported)
            self.tracks = list.tracks.map { $0.asTrack() }
            print("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ \(tracks.count) —Ç—Ä–µ–∫–æ–≤ –∏–∑ \(list.name)")
        } else {
            print("‚ö†Ô∏è –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ç—Ä–µ–∫–ª–∏—Å—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
        }
        
        
        // MARK: - –ò–º–ø–æ—Ä—Ç
        
        // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç —Ç—Ä–µ–∫–∏ –≤ —Ç–µ–∫—É—â–∏–π —Ç—Ä–µ–∫–ª–∏—Å—Ç
        func importTracks(from urls: [URL]) async {
            guard let id = self.currentListId else {
                print("‚ö†Ô∏è –ü–ª–µ–π–ª–∏—Å—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω ‚Äî –∏–º–ø–æ—Ä—Ç –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω")
                return
            }
            
            await ImportManager().importTracks(from: urls, to: id) { imported in
                guard let id = self.currentListId else { return }
                
                var existingTracks = TrackListManager.shared.loadTracks(for: id)
                existingTracks.insert(contentsOf: imported, at: 0)
                TrackListManager.shared.saveTracks(existingTracks, for: id)
                
                DispatchQueue.main.async {
                    self.tracks = existingTracks.map { $0.asTrack() }
                    self.refreshTrackLists()
                    print("‚úÖ –ò–º–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à—ë–Ω: \(imported.count) —Ç—Ä–µ–∫–æ–≤ –¥–æ–±–∞–≤–ª–µ–Ω–æ")
                }
            }
        }
        
        // –°—Ç–∞—Ä—Ç –Ω–æ–≤–æ–≥–æ –∏–º–ø–æ—Ä—Ç–∞ —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º —Ç—Ä–µ–∫–ª–∏—Å—Ç–∞
        func startImportForNewTrackList() {
            print("üñãÔ∏è –í—ã–∑–æ–≤ startImportForNewTrackList. ViewModel: \(ObjectIdentifier(self))")
            importMode = .newList
        }
        
        // –ò–º–ø–æ—Ä—Ç —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º –Ω–æ–≤–æ–≥–æ –ø–ª–µ–π–ª–∏—Å—Ç–∞
        func createNewTrackListViaImport(from urls: [URL]) async {
            await ImportManager().importTracks(from: urls, to: UUID()) { imported in
                guard !imported.isEmpty else {
                    print("‚ö†Ô∏è –¢—Ä–µ–∫–∏ –Ω–µ –≤—ã–±—Ä–∞–Ω—ã, —Ç—Ä–µ–∫–ª–∏—Å—Ç –Ω–µ –±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω")
                    return
                }
                
                let newList = TrackListManager.shared.createTrackList(from: imported)
                
                DispatchQueue.main.async {
                    self.currentListId = newList.id
                    self.tracks = imported.map { $0.asTrack().refreshAvailability() }
                    self.refreshTrackLists()
                    print("‚úÖ –ù–æ–≤—ã–π —Ç—Ä–µ–∫–ª–∏—Å—Ç —Å–æ–∑–¥–∞–Ω —Å \(imported.count) —Ç—Ä–µ–∫–∞–º–∏")
                }
            }
        }
        
        
        // MARK: - –≠–∫—Å–ø–æ—Ä—Ç
        
        // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç—Ä–µ–∫–∏ —Ç–µ–∫—É—â–µ–≥–æ —Ç—Ä–µ–∫–ª–∏—Å—Ç–∞ –≤ –≤—ã–±—Ä–∞–Ω–Ω—É—é –ø–∞–ø–∫—É
        func exportTracks(to folder: URL) {
            guard let id = currentListId else {
                print("‚ö†Ô∏è –ü–ª–µ–π–ª–∏—Å—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω")
                return
            }
            let imported = TrackListManager.shared.loadTracks(for: id)
            let metas = TrackListManager.shared.loadTrackListMetas()
            if let meta = metas.first(where: { $0.id == id }) {
                let list = TrackList(id: id, name: meta.name, createdAt: meta.createdAt, tracks: imported)
                self.tracks = list.tracks.map { $0.asTrack() }
                print("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ \(tracks.count) —Ç—Ä–µ–∫–æ–≤ –∏–∑ \(list.name)")
            } else {
                print("‚ö†Ô∏è –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ç—Ä–µ–∫–ª–∏—Å—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
            }
        }
        
        
        // MARK: - –†–∞–±–æ—Ç–∞ —Å —Ç—Ä–µ–∫–∞–º–∏ –≤ –ø–ª–µ–π–ª–∏—Å—Ç–µ
        
        // –û—á–∏—Å—Ç–∫–∞ —Ç—Ä–µ–∫–ª–∏—Å—Ç–∞
        func clearTrackList(id: UUID) {
            guard id == currentListId else {
                print("‚ö†Ô∏è –û—á–∏—Å—Ç–∫–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞: –ø–ª–µ–π–ª–∏—Å—Ç –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω")
                return
            }
            
            let tracksToClear = TrackListManager.shared.loadTracks(for: id)
            for track in tracksToClear {
                if let artworkId = track.artworkId {
                    ArtworkManager.deleteArtwork(id: artworkId)
                    print("üóëÔ∏è –£–¥–∞–ª–µ–Ω–∞ –æ–±–ª–æ–∂–∫–∞: artwork_\(artworkId).jpg")
                }
            }
            
            TrackListManager.shared.saveTracks([], for: id)
            self.tracks = []
            print("üßπ –í—Å–µ —Ç—Ä–µ–∫–∏ —É–¥–∞–ª–µ–Ω—ã –∏–∑ –ø–ª–µ–π–ª–∏—Å—Ç–∞ \(id)")
        }
    }
        
        // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞
        func moveTrack(from source: IndexSet, to destination: Int) {
            guard let id = currentListId else { return }

            // –ú–µ–Ω—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –≤ —Ç–µ–∫—É—â–µ–º —Å–ø–∏—Å–∫–µ
            tracks.move(fromOffsets: source, toOffset: destination)

            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ ImportedTrack
            let imported = tracks.map { $0.asImportedTrack() }

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫
            TrackListManager.shared.saveTracks(imported, for: id)

            print("‚ÜïÔ∏è –¢—Ä–µ–∫–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã")
        }
    
    
        // –£–¥–∞–ª—è–µ—Ç —Ç—Ä–µ–∫ –ø–æ –∏–Ω–¥–µ–∫—Å–∞–º
        func removeTrack(at offsets: IndexSet) {
            guard let id = currentListId else { return }

            // –£–¥–∞–ª—è–µ–º —Ç—Ä–µ–∫–∏ –∏–∑ –º–∞—Å—Å–∏–≤–∞
            tracks.remove(atOffsets: offsets)

            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ ImportedTrack
            let imported = tracks.map { $0.asImportedTrack() }

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
            TrackListManager.shared.saveTracks(imported, for: id)

        }
        
        
        // MARK: - –¢—Ä–µ–∫–ª–∏—Å—Ç—ã
        
        // –û–±–Ω–æ–≤–ª—è–µ—Ç —Ñ–ª–∞–≥ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —É –∫–∞–∂–¥–æ–≥–æ —Ç—Ä–µ–∫–∞
        func refreshTrackAvailability() {
            self.tracks = self.tracks.map { $0.refreshAvailability() }
            print("‚ôªÔ∏è –ê–∫—Ç—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ç—Ä–µ–∫–æ–≤")
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –º–æ–∂–Ω–æ –ª–∏ —É–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–∫–ª–∏—Å—Ç
        func canDeleteTrackList(id: UUID) -> Bool {
            if id == currentListId {
                let tracks = TrackListManager.shared.loadTracks(for: id)
                return tracks.isEmpty
            } else {
                return true
            }
        }
    
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Ç—Ä–µ–∫–ª–∏—Å—Ç–æ–≤
        func toggleEditMode() {
        isEditing.toggle()
        }
    
        // –ó–∞–ø—É—Å–∫ –∏–º–ø–æ—Ä—Ç–∞ –Ω–æ–≤–æ–≥–æ —Ç—Ä–µ–∫–ª–∏—Å—Ç–∞
        func startImport() {
        importMode = .newList
        }
    
        func deleteTrackList(id: UUID) {
        TrackListManager.shared.deleteTrackList(id: id)
        refreshTrackLists()
        }
    
        
        // MARK: - –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç—Ä–µ–∫–ª–∏—Å—Ç–∞
        
        func saveCurrentTrackList(named newName: String) {
            let tracksToSave = self.tracks.map { $0.asImportedTrack() }
            
            let newList = TrackListManager.shared.createTrackList(
                from: tracksToSave,
                withName: newName
            )
            
            self.currentListId = newList.id
            self.tracks = newList.tracks.compactMap { Track(from: $0) }
            self.refreshTrackLists()
            
            print("‚úÖ –ù–æ–≤—ã–π —Ç—Ä–µ–∫–ª–∏—Å—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: \(newName)")
            showToast(message: "–¢—Ä–µ–∫–ª–∏—Å—Ç ¬´\(newName)¬ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω")
        }
        
        // –¢–æ—Å—Ç
        func showToast(
            message: String,
            title: String? = nil,
            artist: String? = nil,
            artwork: UIImage? = nil,
            duration: TimeInterval = 2.0
        ) {
            if let title = title, let artist = artist {
                self.toastData = ToastData(
                    style: .track(title: title, artist: artist),
                    artwork: artwork
                    
                )
            } else {
                self.toastData = ToastData(
                    style: .trackList(name: message),
                    artwork: nil
                )
            }
            
            DispatchQueue.main.asyncAfter(deadline: .now() + duration) {
                withAnimation {
                    self.toastData = nil
                }
            }
        }
    }
    

    // MARK: - –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ: –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç–∞
    
    extension TrackListViewModel {
        var totalDuration: TimeInterval {
            tracks.reduce(0) { $0 + $1.duration }
        }
        
        var formattedTotalDuration: String {
            let formatter = DateComponentsFormatter()
            formatter.zeroFormattingBehavior = .pad
            
            if totalDuration >= 86400 {
                formatter.allowedUnits = [.day, .hour, .minute]
                formatter.unitsStyle = .short
            } else if totalDuration >= 3600 {
                formatter.allowedUnits = [.hour, .minute]
                formatter.unitsStyle = .short
            } else {
                formatter.allowedUnits = [.minute, .second]
                formatter.unitsStyle = .positional
            }
            
            return formatter.string(from: totalDuration) ?? "0:00"
        }
    }
    

    // MARK: - UIDocumentPickerDelegate: —ç–∫—Å–ø–æ—Ä—Ç –≤ –≤—ã–±—Ä–∞–Ω–Ω—É—é –ø–∞–ø–∫—É
    
    extension TrackListViewModel: UIDocumentPickerDelegate {
        func documentPicker(
            _ controller: UIDocumentPickerViewController,
            didPickDocumentsAt urls: [URL]
        ) {
            Task { @MainActor in
                guard urls.first != nil else {
                    print("‚ö†Ô∏è –ü–∞–ø–∫–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω–∞")
                    return
                }
                
                guard let id = currentListId else {
                    print("‚ö†Ô∏è –ü–ª–µ–π–ª–∏—Å—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω ‚Äî —ç–∫—Å–ø–æ—Ä—Ç –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω")
                    return
                }
                
                let tracks = TrackListManager.shared.loadTracks(for: id)
                let availableTracks = tracks.filter { $0.isAvailable }
                
                if let topVC = UIApplication.topViewController() {
                    ExportManager.shared.exportViaTempAndPicker(
                        availableTracks,
                        presenter: topVC
                    )
                }
            }
        }
    }
    

